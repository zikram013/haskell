
module AllEjercicios where
import Data.Char
import Data.List

--------Tema 2-------

{- Implementar una funcion en haskell que dados tres numeros enteros determine si estan ordenador de menor a mayor-}
estanOrdenados:: Int->Int->Int->Bool
estanOrdenados x y z = (x<y) && (y<z) && (x<z)

{-Implementar una funcion en Haskell que dados tres numeros enteros lo devuelva ordenados de menor a mayor-}
ordenarTresNumeros::Int->Int->Int->[Int]
ordenarTresNumeros x y z 
		|((x<y)&&(x<z)&&(y<z))=[x,y,z]
		|((x<y)&&(x<z)&&(y>z))=[x,z,y]
		|((y<x)&&(x<z)&&(y<z))=[y,x,z]
		|((y<x)&&(x>z)&&(y<z))=[y,z,x]
		|((x<y)&&(z<x)&&(z<y))=[z,x,y]
		|otherwise = [z,y,x]
		
{-Implementar en haskell una funcion que reciba un numero real y devuelva una tupla con su parte entera y sus dos primeros decimales(como numero entero)-}
tuplarDecimal::Float->(Int,Int)
tuplarDecimal n = (truncate n , mod(truncate(n*100))100)

{-Crear una funcion que reciba el readio de una circunferencia y devuelva una 2-tupla con la longitud de la circunferencia y con el area del circulo
Emplea una deficinion local con la clausula where para almacenar el valor de PI
Emplea despues una deficion local let para el mismo cometido-}
areaCirculo::Float->(Float,Float)
areaCirculo r = (2*pic*r , pic*r^2) where pic=3.14

areaCirculoLet::Float->(Float,Float)
areaCirculoLet r = let pic= 3.14 in (2*pic*r , pic*r^2)

{-Implementar la funcion predefinida de listas concatm que se llamara concatenar, utilizando la definicion de listas por compresion-}
concatenar::[[a]]->[a]
concatenar l = [y|x<-l , y<-x]

{-Implementar una funcion que dado un numero entero devuelva en una lista todos los factores de ese numero. Se debe utilizar la definicion de listas por compresion
Tambien llamado todos los divisores de un numero-}
factores::Int->[Int]
factores n = [x | x<-[1..div n 2], mod n x == 0]++ [n]

{-Implementar una funcion que diga si un numero es primo Para ello se deve utilizar la funcion que calcula el numero de factores-}
esPrimo::Int->Bool
esPrimo n = (length (factores n))==2

{-Implementar una funcion que diga cuantos caracteres en mayuscula estan contenidos en una frase dada. Se deberan utillizar listas por compresion-}
mayus::[Char]->Int
mayus frase = length([c | c <-frase, isUpper c])

{-Implementar una funcion que dada una tupla de tres elementos, donde cada uno de ellos es a su vez una tupla de dos elementos de tipo string e int, retorne
el primer elemento de cada tupla interna. Se debera utilizar ajuste de patrones-}
primerElemento:: ((String,Int),(String,Int),(String,Int))->[String]
primerElemento ((x1,x2),(y1,y2),(z1,z2))=[x1,y1,z1]

{-Implementar una funcion que devuelve True si la suma de los cuatro primeros elementos de una lista de numero entero ses un valor menor a 10 y devolvera False 
en caso contrario. Se debera utilizar ajuste de patrones-}
sumaMayor10::[Int]->Bool
sumaMayor10 l = (sum(take 4 l))<10

{-Implementar una funcion que dada una frase retorne un mensaje donde se indique-}
procesarFrase :: [Char]->[Char]
procesarFrase frase = "La letra frase "++[frase!!0]++ "la ultima letra: "++[last frase]

{-Implementar una funcion que dada una cadena de caracteres y un caracter, indique el numero de aparciones del caracter en la adena. No se debe utilizar recurisvidad
si ajuste de patrones. Utilizar por ejemplo listas de compresion -}
contarAparicion:: String->Char->Int
contarAparicion [] e = 0
contarAparacicion frase c = length([x| x<-frase, x==c])

-----Tema 4 -----------------
{-Implementa una funcion en haskell que elimine de una lista de enteros aquellos multiplos de x-}
--Por listas con compresion
eliminarMultiploCompresion::[Int]->Int->[Int]
eliminarMultiploCompresion l e = [x | x<-l, mod e x/=0]
--Recursividad no final
eliminarMultiploNoFinal::[Int]->Int->[Int]
eliminarMultiploNoFinal [] n = []
eliminarMultiploNoFinal (x:xs) n 
		|mod x n == 0 = eliminarMultiploNoFinal xs x
		|otherwise = x:eliminarMultiploNoFinal xs x
--Recurision final
eliminarMultiploFinal::[Int]->Int->[Int]->[Int]
eliminarMultiploFinal [] n ac = ac
eliminarMultiploFinal (x:xs) n ac
		|(mod x n)==0 =eliminarMultiploFinal xs n ac
		|otherwise = eliminarMultiploFinal xs n (ac++[x])
		
{-Dada la siguiente definicion de funcion
doble:: Int-> Int
doble x = x + x
Cambiarla para utilizar expresiones lambda-}
doble::Int->Int
doble = (\x->x+x)

{-Se pide una funcion en haskell que dada una lista de numeros enteros obtenga un numero entero con el resultado de calcular el doble de cada uno de los elementos-}
--Recursividad no final
sumaDobleNoFinal::[Int]->Int
sumaDobleNoFinal []=0
sumaDobleNoFinal (x:xs)= x*2 + (sumaDobleNoFinal xs)

--Recurisividad final
sumaDobleFinal::[Int]->Int->Int
sumaDobleFinal [] ac = ac
sumaDobleFinal (x:xs) ac = sumaDobleFinal xs (x*2 + ac)

--Con funciones lambda o de orden superior (se puede hacer uso de map)
sumaDobleLambdaOrdenSuperior::[Int]->Int
sumaDobleLambdaOrdenSuperior l = foldr (+) 0 (map *2 l)
