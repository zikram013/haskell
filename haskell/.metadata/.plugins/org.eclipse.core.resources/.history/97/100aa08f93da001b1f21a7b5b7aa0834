
module EjerciciosLibro1011exam where
import Data.Char
import Data.List

{-Definiciones sobre cadenas, orden superior y plegado-}

{-1.Una persona es tan agarrada que sólo compra cuando le
-- hacen un descuento del 10% y el precio (con el descuento) es menor o
-- igual que 199.
--
-- Definir, usando comprensión, la función
-- agarrado :: [Float] -> Float
-- tal que (agarrado ps) es el precio que tiene que pagar por una compra
-- cuya lista de precios es ps. Por ejemplo,
-- agarrado [45.00, 199.00, 220.00, 399.00] == 417.59998-}
agarrado::[Float]->Float
agarrado ps = sum [p * 0.9 | p<-ps, p*0.9<=199]
--Definirlo por recurision
agarradoRecursion::[Float]->Float
agarradoRecursion [] = 0
agarradoRecursion (p:ps) 
					|precioConDescuento <=199 = precioConDescuento + agarradoRecursion ps
					|otherwise = agarradoRecursion ps
						where precioConDescuento = p*0.9
						
{-2.La función
-- divideMedia :: [Double] -> ([Double],[Double])
-- dada una lista numérica, xs, calcula el par (ys,zs), donde ys
-- contiene los elementos de xs estrictamente menores que la media,
-- mientras que zs contiene los elementos de xs estrictamente mayores
-- que la media. Por ejemplo,
-- divideMedia [6,7,2,8,6,3,4] == ([2.0,3.0,4.0],[6.0,7.0,8.0,6.0])84 Ejercicios de programación funcional (2011–12)
-- divideMedia [1,2,3] == ([1.0],[3.0])
-- Definir la función divideMedia por filtrado, comprensión y
-- recursión.-}
media::[Double]->Double
media xs = (sum xs)/fromIntegral (length xs)
--filtrado
divideMediaFiltrado::[Double]->([Double],[Double])
divideMediaFiltrado xs = (filter(<m)xs,filter(>m)xs) where m = media xs
--Compresion
divideMediaCompresion::[Double]->([Double],[Double])
divideMediaCompresion xs = ([x | x<-xs,x<m],[x|x<-xs,x>m]) where m = media xs
--recursion
divideMediaRecursion::[Double]->([Double],[Double])
divideMediaRecursion xs = divideMediaAux xs 
	where m = media xs
	      divideMediaAux [] = ([],[])
	      divideMediaAux (x:xs) | x<m=(x:ys,zs)
	      						| x == m = (ys,zs)
	      						|x>m = (ys,x:zs)
	      							where (ys,zs) = divideMediaAux xs
	      							
{-3.Definir, por comprensión, la función
-- sumaDigitos :: String -> Int
-- tal que (sumaDigitos xs) es la suma de los dígitos de la cadena
-- xs. Por ejemplo,
-- sumaDigitos ”SE 2431 X” == 10
-- Nota: Usar las funciones isDigit y digitToInt. Tambien por recursion
-}
sumaDigitos::String->Int
sumaDigitos xs = sum [digitToInt x | x<-xs, isDigit x]

sumaDigitosRecursion::String->Int
sumaDigitosRecursion [] = 0
sumaDigitosRecursion (x:xs) 
						| isDigit x = digitToInt x + sumaDigitosRecursivo xs
						|otherwise = sumaDigitosRecursivo xs