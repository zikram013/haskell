
module EjerciciosLibro1011exam where
import Data.Char
import Data.List

{-Definiciones sobre cadenas, orden superior y plegado-}

{-1.Una persona es tan agarrada que sólo compra cuando le
-- hacen un descuento del 10% y el precio (con el descuento) es menor o
-- igual que 199.
--
-- Definir, usando comprensión, la función
-- agarrado :: [Float] -> Float
-- tal que (agarrado ps) es el precio que tiene que pagar por una compra
-- cuya lista de precios es ps. Por ejemplo,
-- agarrado [45.00, 199.00, 220.00, 399.00] == 417.59998-}
agarrado::[Float]->Float
agarrado ps = sum [p * 0.9 | p<-ps, p*0.9<=199]
--Definirlo por recurision
agarradoRecursion::[Float]->Float
agarradoRecursion [] = 0
agarradoRecursion (p:ps) 
					|precioConDescuento <=199 = precioConDescuento + agarradoRecursion ps
					|otherwise = agarradoRecursion ps
						where precioConDescuento = p*0.9
						
{-2.La función
-- divideMedia :: [Double] -> ([Double],[Double])
-- dada una lista numérica, xs, calcula el par (ys,zs), donde ys
-- contiene los elementos de xs estrictamente menores que la media,
-- mientras que zs contiene los elementos de xs estrictamente mayores
-- que la media. Por ejemplo,
-- divideMedia [6,7,2,8,6,3,4] == ([2.0,3.0,4.0],[6.0,7.0,8.0,6.0])84 Ejercicios de programación funcional (2011–12)
-- divideMedia [1,2,3] == ([1.0],[3.0])
-- Definir la función divideMedia por filtrado, comprensión y
-- recursión.-}
media::[Double]->Double
media xs = (sum xs)/fromIntegral (length xs)
--filtrado
divideMediaFiltrado::[Double]->([Double],[Double])
divideMediaFiltrado xs = (filter(<m)xs,filter(>m)xs) where m = media xs
--Compresion
divideMediaCompresion::[Double]->([Double],[Double])
divideMediaCompresion xs = ([x | x<-xs,x<m],[x|x<-xs,x>m]) where m = media xs
--recursion
divideMediaRecursion::[Double]->([Double],[Double])
divideMediaRecursion xs = divideMediaAux xs 
	where m = media xs
	      divideMediaAux [] = ([],[])
	      divideMediaAux (x:xs) | x<m=(x:ys,zs)
	      						| x == m = (ys,zs)
	      						|x>m = (ys,x:zs)
	      							where (ys,zs) = divideMediaAux xs
	      							
{-3.Definir, por comprensión, la función
-- sumaDigitos :: String -> Int
-- tal que (sumaDigitos xs) es la suma de los dígitos de la cadena
-- xs. Por ejemplo,
-- sumaDigitos ”SE 2431 X” == 10
-- Nota: Usar las funciones isDigit y digitToInt. Tambien por recursion
-}
sumaDigitos::String->Int
sumaDigitos xs = sum [digitToInt x | x<-xs, isDigit x]

sumaDigitosRecursion::String->Int
sumaDigitosRecursion [] = 0
sumaDigitosRecursion (x:xs) 
						|isDigit x = digitToInt x + sumaDigitosRecursion xs
						|otherwise = sumaDigitosRecursion xs
						
{-4. Definir, por comprensión y recursion la función
-- mayusculaInicial :: String -> String
-- tal que (mayusculaInicial xs) es la palabra xs con la letra inicial
-- en mayúscula y las restantes en minúsculas. Por ejemplo,
-- mayusculaInicial ”sEviLLa” == ”Sevilla”
-- Nota: Usar las funciones toLower y toUpper.-}
mayusculaInicial::String->String
mayusculaInicial [] = []
mayusculaInicial (x:xs)=toUpper x : [toLower x |x<-xs]

mayusculaInicialRecursivo::String->String
mayusculaInicialRecursivo [] = []
mayusculaInicialRecursivo (x:xs)=toUpper x : aux xs
	where aux(x:xs) = toLower x :aux xs
	      aux[]=[]
	      
{-5.Se consideran las siguientes reglas de mayúsculas
-- iniciales para los títulos:
-- * la primera palabra comienza en mayúscula y
-- * todas las palabras que tienen 4 letras como mínimo empiezan
-- con mayúsculas
-- Definir, por comprensión, la función
-- titulo :: [String] -> [String]
-- tal que (titulo ps) es la lista de las palabras de ps con
-- las reglas de mayúsculas iniciales de los títulos. Por ejemplo,
-- *Main> titulo [”eL”,”arTE”,”DE”,”La”,”proGraMacion”]
-- [”El”,”Arte”,”de”,”la”,”Programacion”]
Tambien de forma Recurisvo-}
titulo::[String]->[String]
titulo [] = []
titulo (p:ps) = mayusculaInicial p : [transforma p |p<-ps]

tituloRecursivo::[String]->[String]
tituloRecursivo [] = []
tituloRecursivo (p:ps)=mayusculaInicial p : tituloRecursivoAux ps
	where tituloRecursivoAux [] = []
	      tituloRecursivoAux (p:ps) = transforma p : tituloRecursivoAux ps
	      
{-6.Definir, por comprensión, la función
-- buscaCrucigrama :: Char -> Int -> Int -> [String] -> [String]
-- tal que (buscaCrucigrama l pos lon ps) es la lista de las palabras de
-- la lista de palabras ps que tienen longitud lon y poseen la letra l en
-- la posición pos (comenzando en 0). Por ejemplo,
-- *Main> buscaCrucigrama ’c’ 1 7 [”ocaso”, ”casa”, ”ocupado”]
-- [”ocupado”]
-- Tambien hacerlo recursivo-}
buscaCrucigrama::Char->Int->Int->[String]->[String]
buscaCrucigrama l pos lon ps = [p | p<-ps,length p == lon, 0<=pos, pos<length p, p !!pos==l]

transforma::String->String
transforma p |length p>= 4 = mayusculaInicial p
			 | otherwise = minuscula p
			 
minuscula::String->String
minuscula xs = [toLower x | x<-xs]